<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Question & Answer App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: white;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: white;
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .header h1 {
            font-size: 1.2rem;
            margin: 0;
            color: #333;
            font-weight: 600;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .question-section {
            padding: 10px;
            text-align: center;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn:hover {
            background: #f5f5f5;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            color: #666;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .recording-dot {
            width: 8px;
            height: 8px;
            background: #dc3545;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .answer-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .answer-content {
            background: white;
            padding: 20px;
            flex: 1;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            overflow-y: auto;
        }

        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #666;
            font-size: 0.9rem;
            height: 100%;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e1e5e9;
            border-top: 2px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            color: #dc3545;
            font-size: 0.8rem;
            margin-top: 5px;
            display: none;
        }

        .success-message {
            color: #28a745;
            font-size: 0.8rem;
            margin-top: 5px;
            display: none;
        }

        .mic-icon {
            width: 20px;
            height: 20px;
        }

        .search-icon {
            width: 20px;
            height: 20px;
        }

        .api-key-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .api-key-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .api-key-content h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
        }

        .api-key-content p {
            margin-bottom: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .api-key-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #007bff;
        }

        .api-key-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 10px;
        }

        .api-key-btn:hover {
            background: #0056b3;
        }

        .api-key-btn.secondary {
            background: #6c757d;
        }

        .api-key-btn.secondary:hover {
            background: #545b62;
        }

        .api-key-help {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #888;
        }

        .role-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .role-input:focus {
            outline: none;
            border-color: #007bff;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .question-input {
                font-size: 1rem;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .main-content {
                padding: 15px;
            }

            .section-title {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¤ Q&A</h1>
        </div>

        <div class="main-content">
            <div class="question-section">
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="recordButton" class="btn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                            <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                        </svg>
                        <span>Record</span>
                    </button>
                    
                    <button id="stopButton" class="btn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="6" y="6" width="12" height="12"/>
                        </svg>
                        <span>Stop</span>
                    </button>
                </div>

                <div id="recordingIndicator" class="recording-indicator">
                    <div class="recording-dot"></div>
                    Recording...
                </div>

                <div id="errorMessage" class="error-message"></div>
                <div id="successMessage" class="success-message"></div>
            </div>

            <div class="answer-section">
                <div id="answerContent" class="answer-content">
                    <div id="loadingIndicator" class="loading">
                        <div class="spinner"></div>
                        <span>Getting answer...</span>
                    </div>
                    <div id="answerText" style="width: 100%; white-space: pre-wrap; word-wrap: break-word; font-size: 1rem; line-height: 1.6;">Press the button to record your question and get an instant answer.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="api-key-modal">
        <div class="api-key-content">
            <h2>ðŸ”‘ Setup Your Interview Assistant</h2>
            <p>Please enter your OpenAI API key and customize your role.</p>
            <input type="text" id="roleInput" class="role-input" placeholder="Senior Software Architect" />
            <input type="password" id="apiKeyInput" class="api-key-input" placeholder="sk-proj-..." />
            <div>
                <button id="saveApiKey" class="api-key-btn">Save & Continue</button>
                <button id="skipApiKey" class="api-key-btn secondary">Skip (Demo Mode)</button>
            </div>
            <div class="api-key-help">
                Role examples: "Senior Software Engineer", "Data Scientist", "DevOps Engineer", "Product Manager"<br>
                Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a><br>
                Data will be stored in browser memory (cleared on refresh)
            </div>
        </div>
    </div>

    <script>
        class QuestionAnswerApp {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.recognition = null;
                this.currentQuestion = '';
                this.latestInterimTranscript = '';
                this.hasShownFirstChunk = false;
                this.apiKey = null;
                this.isDemoMode = false;
                this.userRole = 'Senior Software Architect';
                
                this.initializeElements();
                this.setupEventListeners();
                this.initializeSpeechRecognition();
                this.showApiKeyModal();
            }

            initializeElements() {
                this.recordButton = document.getElementById('recordButton');
                this.stopButton = document.getElementById('stopButton');
                this.recordingIndicator = document.getElementById('recordingIndicator');
                this.answerText = document.getElementById('answerText');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.errorMessage = document.getElementById('errorMessage');
                this.successMessage = document.getElementById('successMessage');
                this.apiKeyModal = document.getElementById('apiKeyModal');
                this.apiKeyInput = document.getElementById('apiKeyInput');
                this.roleInput = document.getElementById('roleInput');
                this.saveApiKeyBtn = document.getElementById('saveApiKey');
                this.skipApiKeyBtn = document.getElementById('skipApiKey');
            }

            setupEventListeners() {
                this.recordButton.addEventListener('click', () => this.startRecording());
                this.stopButton.addEventListener('click', () => this.stopRecording());
                this.saveApiKeyBtn.addEventListener('click', () => this.saveApiKey());
                this.skipApiKeyBtn.addEventListener('click', () => this.skipApiKey());
                this.apiKeyInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.saveApiKey();
                    }
                });
                this.roleInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.saveApiKey();
                    }
                });
            }

            initializeSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'en-US';
                    this.recognition.maxAlternatives = 1;

                    this.recognition.onresult = (event) => {
                        console.log('Speech recognition result:', event);
                        let finalTranscript = '';
                        let interimTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            console.log('Transcript:', transcript, 'isFinal:', event.results[i].isFinal);
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript;
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        // Update current question with final results
                        if (finalTranscript) {
                            this.currentQuestion += finalTranscript;
                            console.log('Updated question:', this.currentQuestion);
                        }
                        
                        // Also update with interim results for better user experience
                        if (interimTranscript) {
                            this.showMessage('Listening... ' + interimTranscript, 'success');
                        }
                        
                        // Store the latest interim result as well for when we stop
                        if (interimTranscript) {
                            this.latestInterimTranscript = interimTranscript;
                        }
                    };

                    this.recognition.onerror = (event) => {
                        console.log('Speech recognition error:', event.error);
                        this.showMessage('Speech recognition error: ' + event.error, 'error');
                    };

                    this.recognition.onstart = () => {
                        console.log('Speech recognition started');
                        this.showMessage('Speech recognition started', 'success');
                    };

                    this.recognition.onend = () => {
                        console.log('Speech recognition ended');
                        // Don't stop automatically, keep listening
                        if (this.isRecording) {
                            this.recognition.start();
                        }
                    };
                } else {
                    this.showMessage('Speech recognition not supported in this browser', 'error');
                }
            }

            updateButtonState() {
                if (this.isRecording) {
                    this.recordButton.style.display = 'none';
                    this.stopButton.style.display = 'flex';
                } else {
                    this.recordButton.style.display = 'flex';
                    this.stopButton.style.display = 'none';
                }
            }

            async startRecording() {
                try {
                    // Check if we have API key or in demo mode
                    if (!this.apiKey && !this.isDemoMode) {
                        this.showApiKeyModal();
                        return;
                    }

                    if (this.isDemoMode) {
                        this.showMessage('Demo mode: Please enter API key to use voice Q&A', 'error');
                        return;
                    }
                    
                    // Clear previous question and answer when starting new recording
                    this.currentQuestion = '';
                    this.answerText.textContent = 'Listening... Speak your question.';
                    this.hideMessages();
                    
                    if (this.recognition) {
                        this.recognition.start();
                        this.isRecording = true;
                        this.updateButtonState();
                        this.updateRecordingUI(true);
                        this.showMessage('Recording started. Speak your question now.', 'success');
                    } else {
                        this.showMessage('Speech recognition not available', 'error');
                    }
                } catch (error) {
                    this.showMessage('Error starting recording: ' + error.message, 'error');
                }
            }

            stopRecording() {
                if (this.recognition && this.isRecording) {
                    this.recognition.stop();
                    this.isRecording = false;
                    this.updateButtonState();
                    this.updateRecordingUI(false);
                    
                    // Get answer if we have a question
                    console.log('Current question:', this.currentQuestion);
                    console.log('Latest interim transcript:', this.latestInterimTranscript);
                    
                    // Use final question or latest interim transcript
                    const questionToUse = this.currentQuestion.trim() || this.latestInterimTranscript.trim();
                    
                    if (questionToUse) {
                        this.currentQuestion = questionToUse;
                        this.showMessage('Question recorded! Getting answer...', 'success');
                        this.searchAnswer();
                    } else {
                        this.showMessage('No question recorded. Please try again.', 'error');
                    }
                }
            }

            updateRecordingUI(recording) {
                this.recordingIndicator.style.display = recording ? 'flex' : 'none';
            }

            async searchAnswer() {
                const question = this.currentQuestion.trim();
                
                if (!question) {
                    this.showMessage('Please record a question first', 'error');
                    return;
                }

                this.hideMessages();
                
                // Initialize UI for streaming
                this.hasShownFirstChunk = false;
                this.answerText.textContent = '';
                this.showLoading(true);

                try {
                    // Get streaming answer
                    await this.getLLMAnswer(question);
                    
                } catch (error) {
                    console.error('LLM error:', error);
                    this.showMessage('Error getting AI answer: ' + error.message, 'error');
                    this.displayAnswer('Sorry, I encountered an error while getting an AI answer. Please try again.');
                } finally {
                    this.showLoading(false);
                }
            }

            async getLLMAnswer(question) {
                try {
                    console.log('Getting streaming answer for question:', question);
                    
                    if (!this.apiKey) {
                        return 'Please enter your OpenAI API key to get AI answers.';
                    }

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout for streaming
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                        },
                        signal: controller.signal,
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a ${this.userRole} with 13-15 years of experience. Give detailed, technical interview answers with real examples. Be conversational and authentic. Need to the point answers, don't want "Absolutely" and all`
                                },
                                {
                                    role: 'user',
                                    content: question
                                }
                            ],
                            max_tokens: 1000,
                            temperature: 0.3,
                            top_p: 0.9,
                            frequency_penalty: 0,
                            presence_penalty: 0,
                            stream: true
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                    }

                    clearTimeout(timeoutId);
                    
                    // Process streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let fullAnswer = '';
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            const chunk = decoder.decode(value);
                            const lines = chunk.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6).trim();
                                    if (data === '[DONE]') {
                                        console.log('Streaming completed');
                                        return;
                                    }
                                    
                                    if (data && data !== '') {
                                        try {
                                            const parsed = JSON.parse(data);
                                            const content = parsed.choices?.[0]?.delta?.content;
                                            if (content) {
                                                fullAnswer += content;
                                                this.displayStreamingAnswer(fullAnswer);
                                            }
                                        } catch (e) {
                                            console.log('Skipping invalid JSON:', data);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }

                } catch (error) {
                    console.error('OpenAI API error:', error);
                    
                    // Check for specific error types
                    if (error.name === 'AbortError') {
                        this.displayAnswer('Request timed out. Please try again with a shorter question.');
                    } else if (error.message.includes('401')) {
                        this.displayAnswer('Invalid API key. Please check your OpenAI API key and try again.');
                    } else if (error.message.includes('429')) {
                        this.displayAnswer('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (error.message.includes('insufficient_quota')) {
                        this.displayAnswer('Insufficient API credits. Please add credits to your OpenAI account.');
                    } else if (error.message.includes('network') || error.message.includes('fetch')) {
                        this.displayAnswer('Network error. Please check your internet connection and try again.');
                    } else {
                        this.displayAnswer(`Error getting ChatGPT response: ${error.message}. Please try again or check your API key.`);
                    }
                    throw error;
                }
            }

            generateFallbackAnswer(question) {
                // This method is no longer used since ChatGPT API handles errors directly
                return 'Unable to get ChatGPT response. Please check your API key and internet connection.';
            }

            displayAnswer(answer) {
                this.answerText.textContent = answer;
                // Answer stays displayed until next record is clicked
            }
            
            displayStreamingAnswer(answer) {
                // Hide loading indicator on first chunk
                if (!this.hasShownFirstChunk) {
                    this.showLoading(false);
                    this.hasShownFirstChunk = true;
                }
                
                this.answerText.textContent = answer;
            }

            hideMessages() {
                this.errorMessage.style.display = 'none';
                this.successMessage.style.display = 'none';
            }

            resetApp() {
                this.currentQuestion = '';
                this.updateButtonState();
                this.answerText.textContent = 'Press the button to record your question and get an instant answer.';
                this.hideMessages();
            }

            showLoading(show) {
                this.loadingIndicator.style.display = show ? 'flex' : 'none';
                this.answerText.style.display = show ? 'none' : 'block';
            }

            showMessage(message, type) {
                this.hideMessages();
                const messageElement = type === 'error' ? this.errorMessage : this.successMessage;
                messageElement.textContent = message;
                messageElement.style.display = 'block';
                
                // Auto-hide success messages after 3 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        messageElement.style.display = 'none';
                    }, 3000);
                }
            }

            showApiKeyModal() {
                this.apiKeyModal.style.display = 'flex';
                this.apiKeyInput.focus();
            }

            hideApiKeyModal() {
                this.apiKeyModal.style.display = 'none';
            }

            saveApiKey() {
                const key = this.apiKeyInput.value.trim();
                const role = this.roleInput.value.trim();
                
                if (!key) {
                    this.showMessage('Please enter an API key', 'error');
                    return;
                }

                if (!key.startsWith('sk-')) {
                    this.showMessage('Invalid API key format. Should start with sk-', 'error');
                    return;
                }

                this.apiKey = key;
                this.userRole = role || 'Senior Software Architect';
                this.isDemoMode = false;
                this.hideApiKeyModal();
                this.showMessage(`Setup complete! Role: ${this.userRole}`, 'success');
            }

            skipApiKey() {
                this.apiKey = null;
                this.isDemoMode = true;
                this.hideApiKeyModal();
                this.showMessage('Demo mode activated. API key required for AI answers.', 'error');
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new QuestionAnswerApp();
        });
    </script>
</body>
</html>